// This is the best I can do for the code without testing on motor and having the encoder 
#include <Encoder.h> // have to install encoder library see instructions on handout
#include <Wire.h>

#define SLAVE_ADDRESS 0x04
#define LOOP_DELAY 50

Encoder knobLeft(2, 5);
Encoder knobRight(7, 8);
double Kp = 1.5;     //4.04279756570629;  //1902322209485; // This value works
//double Kp = 1.743511643388056;  // This value works
//double Kp = 1;
//double Ki = 0;   //609397897048;
double Ki = 0.09; //31442; //08562799;
//double Kd = 0.569618462570328;
double Kd = 0.7;
double r = 0;
int number = 0; // Data recieved
double angVel = 0;
double prePos = 0;
void setup() {
  // put your setup code here, to run once:
  pinMode(4, OUTPUT);
  pinMode(7, OUTPUT);
  pinMode(8, OUTPUT);
  pinMode(9, OUTPUT);
  pinMode(10, OUTPUT);
  digitalWrite(4, HIGH);
  pinMode(12, INPUT);
  Serial.begin(9600); 
  // initialize i2c as slave
  Wire.begin(SLAVE_ADDRESS);
  // define callbacks for i2c communication
  Wire.onReceive(receiveData);
  //Wire.onRequest(sendData); 
  delay(1000);
}

long postitionLeft =-999;
//long positionRight = -999;
long leftAng = 0;
double I = 0;
double D = 0;
double ePast = 0;
double Ts = 0;
double Tc = millis()/1000;
double u = 0;
double i = 0;
double umax = 7.2;
 
void loop() {  
   //time1 = micros();

   if (number == 2) {
    r = 1.57;
   } else if (number == 3) {
    r = 3.14;
   } else if (number == 4) {
    r = -1.57;
   } else if (number == 1){
    r = 0;
   }
   //r = 3.14;
   //Serial.println(r); // Remove later
   long newLeft; // new postion
   newLeft=knobLeft.read(); //% 3200; // mod so that output is between 0 and 2 pi
   double leftAng =  (double)newLeft * 6.28 / 3200; // calulation of angular position

    // reset both back to zero.
  if (Serial.available()) {
    Serial.read();
    Serial.println("Reset both knobs to zero");
    knobLeft.write(0);
    knobRight.write(0);
  }
    Serial.print(micros());
    Serial.print(",");
    Serial.print(leftAng);
    Serial.print(",");
    angVel = (leftAng - (r - ePast))/Ts;
    Serial.print(angVel);
    Serial.println();

    Serial.println(number);
    Serial.println();

   double e = r - leftAng; // Error in rad
   Serial.print("Error: ");
   Serial.println(e);
   if (abs(e) <= 0.02) {
    Ki = 0;
   }
   if (Ts > 0) {
     D = (e - ePast)/Ts; // rad/sec Derivative 
     ePast = e;
   }
   else {
     D = 0; // rad/sec
   }
   I = I + Ts*e; // Rad*s
   u = Kp*e + Ki*I + Kd*D; // (V/rad) * rad + (V/rad*sec) * (rad/sec) + (V/(rad/sec)) * (rad/sec)
   // Final Units from above is only V
  Serial.print("Volts Out Unmaxed: ");
   Serial.print(u);
   Serial.println();
   if (abs(u) > umax) {
    u = umax;
     //u = signbit(u)*umax;
     //I = (u-Kp*e-Kd*D)/Ki;
   }
  // u = umax - u;
  if (abs(u) < 0.005) {
    u = 0;
   }
   Serial.print("Volts Out Maxed: ");
   Serial.print(u);
   Serial.println();
   i = (u / umax) * 255;
   Serial.print("Motor Command: ");
   Serial.print(i);
   Serial.println();

   analogWrite(9, abs(i));
   digitalWrite(7, signbit(-1*u));
   Ts = ((millis()/1000) - Tc);
   Tc = millis()/1000;
   //Serial.print("Loop :");
   //Serial.println(Ts);
   
   delay(LOOP_DELAY);
   
    
} // End loop

int stop = 0;

void receiveData(int byteCount){
  while(Wire.available()) {
    number = Wire.read();
  } // End while
} // End void

void sendData(){
  Wire.write(number);
}
